package config

import (
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestConfig_ValidateEnhanced_Valid(t *testing.T) {
	cfg := &Config{
		Server: ServerConfig{
			Address:        ":8080",
			MetricsPath:    "/metrics",
			HealthPath:     "/health",
			ReadyPath:      "/ready",
			Timeout:        30 * time.Second,
			ReadTimeout:    30 * time.Second,
			WriteTimeout:   30 * time.Second,
			MaxRequestSize: 10 * 1024 * 1024,
		},
		SLURM: SLURMConfig{
			BaseURL: "http://localhost:6820",
			Timeout: 30 * time.Second,
			Auth: AuthConfig{
				Type:  "jwt",
				Token: "valid-jwt-token",
			},
		},
		Collectors: CollectorsConfig{
			Global: GlobalCollectorConfig{
				DefaultInterval: 15 * time.Second,
			},
			Jobs: CollectorConfig{
				Enabled: true,
				Timeout: 15 * time.Second,
				Filters: FilterConfig{
					Metrics: MetricFilterConfig{
						EnableAll: true,
					},
				},
			},
		},
		Metrics: MetricsConfig{
			Cardinality: CardinalityConfig{
				WarnLimit: 5000,
				MaxSeries: 10000,
			},
		},
	}

	err := cfg.ValidateEnhanced()
	assert.NoError(t, err)
}

func TestConfig_ValidateEnhanced_ServerErrors(t *testing.T) {
	tests := []struct {
		name   string
		config *Config
		errMsg string
	}{
		{
			name: "invalid address",
			config: &Config{
				Server: ServerConfig{
					Address: "invalid",
					MetricsPath: "/metrics",
					HealthPath: "/health",
				},
				SLURM: SLURMConfig{
					BaseURL: "http://localhost:6820",
					Timeout: 30 * time.Second,
				},
				Collectors: CollectorsConfig{
					Global: GlobalCollectorConfig{
						DefaultInterval: 15 * time.Second,
					},
					Jobs: CollectorConfig{
						Enabled: true,
						Filters: FilterConfig{
							Metrics: MetricFilterConfig{EnableAll: true},
						},
					},
				},
				Metrics: MetricsConfig{
					Cardinality: CardinalityConfig{
						WarnLimit: 5000,
						MaxSeries: 10000,
					},
				},
			},
			errMsg: "[INVALID_SERVER_ADDRESS]",
		},
		{
			name: "invalid metrics path",
			config: &Config{
				Server: ServerConfig{
					Address:     ":8080",
					MetricsPath: "metrics", // missing leading slash
					HealthPath:  "/health",
				},
				SLURM: SLURMConfig{
					BaseURL: "http://localhost:6820",
					Timeout: 30 * time.Second,
				},
				Collectors: CollectorsConfig{
					Global: GlobalCollectorConfig{
						DefaultInterval: 15 * time.Second,
					},
					Jobs: CollectorConfig{
						Enabled: true,
						Filters: FilterConfig{
							Metrics: MetricFilterConfig{EnableAll: true},
						},
					},
				},
				Metrics: MetricsConfig{
					Cardinality: CardinalityConfig{
						WarnLimit: 5000,
						MaxSeries: 10000,
					},
				},
			},
			errMsg: "[INVALID_METRICS_PATH]",
		},
		{
			name: "timeouts too short",
			config: &Config{
				Server: ServerConfig{
					Address:      ":8080",
					MetricsPath:  "/metrics",
					HealthPath:   "/health",
					ReadyPath:    "/ready",
					ReadTimeout:  100 * time.Millisecond,
					WriteTimeout: 100 * time.Millisecond,
				},
				SLURM: SLURMConfig{
					BaseURL: "http://localhost:6820",
					Timeout: 30 * time.Second,
				},
				Collectors: CollectorsConfig{
					Global: GlobalCollectorConfig{
						DefaultInterval: 15 * time.Second,
					},
					Jobs: CollectorConfig{
						Enabled: true,
						Filters: FilterConfig{
							Metrics: MetricFilterConfig{EnableAll: true},
						},
					},
				},
				Metrics: MetricsConfig{
					Cardinality: CardinalityConfig{
						WarnLimit: 5000,
						MaxSeries: 10000,
					},
				},
			},
			errMsg: "[SERVER_TIMEOUT_TOO_SHORT]",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.config.ValidateEnhanced()
			assert.Error(t, err)
			assert.Contains(t, err.Error(), tt.errMsg)
		})
	}
}

func TestConfig_ValidateEnhanced_SLURMErrors(t *testing.T) {
	tests := []struct {
		name   string
		config *Config
		errMsg string
	}{
		{
			name: "missing base URL",
			config: &Config{
				Server: ServerConfig{
					Address:     ":8080",
					MetricsPath: "/metrics",
					HealthPath:  "/health",
					ReadyPath:   "/ready",
				},
				SLURM: SLURMConfig{
					BaseURL: "",
					Timeout: 20 * time.Second,
				},
				Collectors: CollectorsConfig{
					Global: GlobalCollectorConfig{
						DefaultInterval: 15 * time.Second,
					},
					Jobs: CollectorConfig{
						Enabled: true,
						Filters: FilterConfig{
							Metrics: MetricFilterConfig{EnableAll: true},
						},
					},
				},
				Metrics: MetricsConfig{
					Cardinality: CardinalityConfig{
						WarnLimit: 5000,
						MaxSeries: 10000,
					},
				},
			},
			errMsg: "[SLURM_BASE_URL_REQUIRED]",
		},
		{
			name: "invalid base URL",
			config: &Config{
				Server: ServerConfig{
					Address:     ":8080",
					MetricsPath: "/metrics",
					HealthPath:  "/health",
					ReadyPath:   "/ready",
				},
				SLURM: SLURMConfig{
					BaseURL: "not-a-url",
					Timeout: 20 * time.Second,
				},
				Collectors: CollectorsConfig{
					Global: GlobalCollectorConfig{
						DefaultInterval: 15 * time.Second,
					},
					Jobs: CollectorConfig{
						Enabled: true,
						Filters: FilterConfig{
							Metrics: MetricFilterConfig{EnableAll: true},
						},
					},
				},
				Metrics: MetricsConfig{
					Cardinality: CardinalityConfig{
						WarnLimit: 5000,
						MaxSeries: 10000,
					},
				},
			},
			errMsg: "[INVALID_SLURM_BASE_URL]",
		},
		{
			name: "invalid auth type",
			config: &Config{
				Server: ServerConfig{
					Address:     ":8080",
					MetricsPath: "/metrics",
					HealthPath:  "/health",
					ReadyPath:   "/ready",
				},
				SLURM: SLURMConfig{
					BaseURL: "http://localhost:6820",
					Timeout: 20 * time.Second,
					Auth: AuthConfig{
						Type: "invalid",
					},
				},
				Collectors: CollectorsConfig{
					Global: GlobalCollectorConfig{
						DefaultInterval: 15 * time.Second,
					},
					Jobs: CollectorConfig{
						Enabled: true,
						Filters: FilterConfig{
							Metrics: MetricFilterConfig{EnableAll: true},
						},
					},
				},
				Metrics: MetricsConfig{
					Cardinality: CardinalityConfig{
						WarnLimit: 5000,
						MaxSeries: 10000,
					},
				},
			},
			errMsg: "[INVALID_AUTH_TYPE]",
		},
		{
			name: "missing JWT path",
			config: &Config{
				Server: ServerConfig{
					Address:     ":8080",
					MetricsPath: "/metrics",
					HealthPath:  "/health",
					ReadyPath:   "/ready",
				},
				SLURM: SLURMConfig{
					BaseURL: "http://localhost:6820",
					Timeout: 20 * time.Second,
					Auth: AuthConfig{
						Type:      "jwt",
						TokenFile: "",
					},
				},
				Collectors: CollectorsConfig{
					Global: GlobalCollectorConfig{
						DefaultInterval: 15 * time.Second,
					},
					Jobs: CollectorConfig{
						Enabled: true,
						Filters: FilterConfig{
							Metrics: MetricFilterConfig{EnableAll: true},
						},
					},
				},
				Metrics: MetricsConfig{
					Cardinality: CardinalityConfig{
						WarnLimit: 5000,
						MaxSeries: 10000,
					},
				},
			},
			errMsg: "[JWT_TOKEN_REQUIRED]",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.config.ValidateEnhanced()
			assert.Error(t, err)
			assert.Contains(t, err.Error(), tt.errMsg)
		})
	}
}

func TestConfig_ValidateEnhanced_CollectorErrors(t *testing.T) {
	tests := []struct {
		name   string
		config *Config
		errMsg string
	}{
		{
			name: "collector timeout too short",
			config: &Config{
				Server: ServerConfig{
					Address:     ":8080",
					MetricsPath: "/metrics",
					HealthPath:  "/health",
					ReadyPath:   "/ready",
				},
				SLURM: SLURMConfig{
					BaseURL: "http://localhost:6820",
					Timeout: 30 * time.Second,
				},
				Collectors: CollectorsConfig{
					Global: GlobalCollectorConfig{
						DefaultInterval: 15 * time.Second,
					},
					Jobs: CollectorConfig{
						Enabled: true,
						Timeout: 100 * time.Millisecond,
						Filters: FilterConfig{
							Metrics: MetricFilterConfig{EnableAll: true},
						},
					},
				},
				Metrics: MetricsConfig{
					Cardinality: CardinalityConfig{
						WarnLimit: 5000,
						MaxSeries: 10000,
					},
				},
			},
			errMsg: "[COLLECTOR_TIMEOUT_TOO_SHORT]",
		},
		{
			name: "collector timeout exceeds SLURM timeout",
			config: &Config{
				Server: ServerConfig{
					Address:     ":8080",
					MetricsPath: "/metrics",
					HealthPath:  "/health",
					ReadyPath:   "/ready",
				},
				SLURM: SLURMConfig{
					BaseURL: "http://localhost:6820",
					Timeout: 10 * time.Second,
				},
				Collectors: CollectorsConfig{
					Global: GlobalCollectorConfig{
						DefaultInterval: 15 * time.Second,
					},
					Jobs: CollectorConfig{
						Enabled: true,
						Timeout: 15 * time.Second,
						Filters: FilterConfig{
							Metrics: MetricFilterConfig{EnableAll: true},
						},
					},
				},
				Metrics: MetricsConfig{
					Cardinality: CardinalityConfig{
						WarnLimit: 5000,
						MaxSeries: 10000,
					},
				},
			},
			errMsg: "[SLURM_TIMEOUT_TOO_SHORT]",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.config.ValidateEnhanced()
			assert.Error(t, err)
			assert.Contains(t, err.Error(), tt.errMsg)
		})
	}
}

func TestConfig_ValidateEnhanced_FilterErrors(t *testing.T) {
	tests := []struct {
		name   string
		config *Config
		errMsg string
	}{
		{
			name: "conflicting filter flags",
			config: &Config{
				Server: ServerConfig{
					Address:     ":8080",
					MetricsPath: "/metrics",
					HealthPath:  "/health",
					ReadyPath:   "/ready",
				},
				SLURM: SLURMConfig{
					BaseURL: "http://localhost:6820",
					Timeout: 30 * time.Second,
				},
				Collectors: CollectorsConfig{
					Global: GlobalCollectorConfig{
						DefaultInterval: 15 * time.Second,
					},
					Jobs: CollectorConfig{
						Enabled: true,
						Filters: FilterConfig{
							Metrics: MetricFilterConfig{
								OnlyCounters: true,
								OnlyGauges:   true,
							},
						},
					},
				},
				Metrics: MetricsConfig{
					Cardinality: CardinalityConfig{
						WarnLimit: 5000,
						MaxSeries: 10000,
					},
				},
			},
			errMsg: "[CONFLICTING_FILTERS]",
		},
		{
			name: "invalid wildcard pattern",
			config: &Config{
				Server: ServerConfig{
					Address:     ":8080",
					MetricsPath: "/metrics",
					HealthPath:  "/health",
					ReadyPath:   "/ready",
				},
				SLURM: SLURMConfig{
					BaseURL: "http://localhost:6820",
					Timeout: 30 * time.Second,
				},
				Collectors: CollectorsConfig{
					Global: GlobalCollectorConfig{
						DefaultInterval: 15 * time.Second,
					},
					Jobs: CollectorConfig{
						Enabled: true,
						Filters: FilterConfig{
							Metrics: MetricFilterConfig{
								IncludeMetrics: []string{"slurm_job_[*"},
							},
						},
					},
				},
				Metrics: MetricsConfig{
					Cardinality: CardinalityConfig{
						WarnLimit: 5000,
						MaxSeries: 10000,
					},
				},
			},
			errMsg: "[INVALID_METRIC_PATTERN]",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.config.ValidateEnhanced()
			assert.Error(t, err)
			assert.Contains(t, err.Error(), tt.errMsg)
		})
	}
}

func TestConfig_ValidateEnhanced_CrossFieldValidation(t *testing.T) {
	cfg := &Config{
		Server: ServerConfig{
			Address:      ":8080",
			MetricsPath:  "/metrics",
			HealthPath:   "/health",
			ReadTimeout:  5 * time.Second,
			WriteTimeout: 30 * time.Second,
			TLS: TLSConfig{
				Enabled:  true,
				CertFile: "", // missing cert
			},
		},
		SLURM: SLURMConfig{
			BaseURL: "http://localhost:6820",
			Timeout: 20 * time.Second,
		},
		Collectors: CollectorsConfig{
			Global: GlobalCollectorConfig{
				DefaultInterval: 15 * time.Second,
			},
			Jobs: CollectorConfig{
				Enabled: true,
				Filters: FilterConfig{
					Metrics: MetricFilterConfig{EnableAll: true},
				},
			},
		},
		Metrics: MetricsConfig{
			Cardinality: CardinalityConfig{
				WarnLimit: 5000,
				MaxSeries: 10000,
			},
		},
	}

	err := cfg.ValidateEnhanced()
	assert.Error(t, err)

	// Should have multiple errors
	validationErrs, ok := err.(ValidationErrors)
	assert.True(t, ok)
	assert.True(t, len(validationErrs) > 1)

	// Check for specific errors
	errMessages := []string{}
	for _, e := range validationErrs {
		errMessages = append(errMessages, e.Error())
	}

	// Check that the error message contains TLS cert requirement
	found := false
	for _, msg := range errMessages {
		if strings.Contains(msg, "TLS_CERT_REQUIRED") {
			found = true
			break
		}
	}
	assert.True(t, found, "Should contain TLS_CERT_REQUIRED error")
}

func TestValidationErrors_Error(t *testing.T) {
	errs := ValidationErrors{
		ValidationError{Field: "server.address", Message: "invalid address"},
		ValidationError{Field: "slurm.timeout", Message: "timeout too short"},
	}

	errStr := errs.Error()
	assert.Contains(t, errStr, "configuration validation failed")
	assert.Contains(t, errStr, "server.address")
	assert.Contains(t, errStr, "slurm.timeout")
}