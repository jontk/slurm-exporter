// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	interfaces "github.com/jontk/slurm-client/interfaces"
	mock "github.com/stretchr/testify/mock"
)

// MockAccountManager is an autogenerated mock type for the AccountManager type
type MockAccountManager struct {
	mock.Mock
}

// Create provides a mock function with given fields: ctx, account
func (_m *MockAccountManager) Create(ctx context.Context, account *interfaces.AccountCreate) (*interfaces.AccountCreateResponse, error) {
	ret := _m.Called(ctx, account)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *interfaces.AccountCreateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *interfaces.AccountCreate) (*interfaces.AccountCreateResponse, error)); ok {
		return rf(ctx, account)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *interfaces.AccountCreate) *interfaces.AccountCreateResponse); ok {
		r0 = rf(ctx, account)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.AccountCreateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *interfaces.AccountCreate) error); ok {
		r1 = rf(ctx, account)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAssociation provides a mock function with given fields: ctx, userName, accountName, opts
func (_m *MockAccountManager) CreateAssociation(ctx context.Context, userName string, accountName string, opts *interfaces.AssociationOptions) (*interfaces.AssociationCreateResponse, error) {
	ret := _m.Called(ctx, userName, accountName, opts)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssociation")
	}

	var r0 *interfaces.AssociationCreateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *interfaces.AssociationOptions) (*interfaces.AssociationCreateResponse, error)); ok {
		return rf(ctx, userName, accountName, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *interfaces.AssociationOptions) *interfaces.AssociationCreateResponse); ok {
		r0 = rf(ctx, userName, accountName, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.AssociationCreateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *interfaces.AssociationOptions) error); ok {
		r1 = rf(ctx, userName, accountName, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: ctx, accountName
func (_m *MockAccountManager) Delete(ctx context.Context, accountName string) error {
	ret := _m.Called(ctx, accountName)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, accountName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: ctx, accountName
func (_m *MockAccountManager) Get(ctx context.Context, accountName string) (*interfaces.Account, error) {
	ret := _m.Called(ctx, accountName)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *interfaces.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*interfaces.Account, error)); ok {
		return rf(ctx, accountName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *interfaces.Account); ok {
		r0 = rf(ctx, accountName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, accountName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountFairShare provides a mock function with given fields: ctx, accountName
func (_m *MockAccountManager) GetAccountFairShare(ctx context.Context, accountName string) (*interfaces.AccountFairShare, error) {
	ret := _m.Called(ctx, accountName)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountFairShare")
	}

	var r0 *interfaces.AccountFairShare
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*interfaces.AccountFairShare, error)); ok {
		return rf(ctx, accountName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *interfaces.AccountFairShare); ok {
		r0 = rf(ctx, accountName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.AccountFairShare)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, accountName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountHierarchy provides a mock function with given fields: ctx, rootAccount
func (_m *MockAccountManager) GetAccountHierarchy(ctx context.Context, rootAccount string) (*interfaces.AccountHierarchy, error) {
	ret := _m.Called(ctx, rootAccount)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountHierarchy")
	}

	var r0 *interfaces.AccountHierarchy
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*interfaces.AccountHierarchy, error)); ok {
		return rf(ctx, rootAccount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *interfaces.AccountHierarchy); ok {
		r0 = rf(ctx, rootAccount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.AccountHierarchy)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, rootAccount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountQuotaUsage provides a mock function with given fields: ctx, accountName, timeframe
func (_m *MockAccountManager) GetAccountQuotaUsage(ctx context.Context, accountName string, timeframe string) (*interfaces.AccountUsage, error) {
	ret := _m.Called(ctx, accountName, timeframe)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountQuotaUsage")
	}

	var r0 *interfaces.AccountUsage
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*interfaces.AccountUsage, error)); ok {
		return rf(ctx, accountName, timeframe)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *interfaces.AccountUsage); ok {
		r0 = rf(ctx, accountName, timeframe)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.AccountUsage)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, accountName, timeframe)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountQuotas provides a mock function with given fields: ctx, accountName
func (_m *MockAccountManager) GetAccountQuotas(ctx context.Context, accountName string) (*interfaces.AccountQuota, error) {
	ret := _m.Called(ctx, accountName)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountQuotas")
	}

	var r0 *interfaces.AccountQuota
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*interfaces.AccountQuota, error)); ok {
		return rf(ctx, accountName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *interfaces.AccountQuota); ok {
		r0 = rf(ctx, accountName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.AccountQuota)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, accountName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountUsers provides a mock function with given fields: ctx, accountName, opts
func (_m *MockAccountManager) GetAccountUsers(ctx context.Context, accountName string, opts *interfaces.ListAccountUsersOptions) ([]*interfaces.UserAccountAssociation, error) {
	ret := _m.Called(ctx, accountName, opts)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountUsers")
	}

	var r0 []*interfaces.UserAccountAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *interfaces.ListAccountUsersOptions) ([]*interfaces.UserAccountAssociation, error)); ok {
		return rf(ctx, accountName, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *interfaces.ListAccountUsersOptions) []*interfaces.UserAccountAssociation); ok {
		r0 = rf(ctx, accountName, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*interfaces.UserAccountAssociation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *interfaces.ListAccountUsersOptions) error); ok {
		r1 = rf(ctx, accountName, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountUsersWithPermissions provides a mock function with given fields: ctx, accountName, permissions
func (_m *MockAccountManager) GetAccountUsersWithPermissions(ctx context.Context, accountName string, permissions []string) ([]*interfaces.UserAccountAssociation, error) {
	ret := _m.Called(ctx, accountName, permissions)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountUsersWithPermissions")
	}

	var r0 []*interfaces.UserAccountAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) ([]*interfaces.UserAccountAssociation, error)); ok {
		return rf(ctx, accountName, permissions)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) []*interfaces.UserAccountAssociation); ok {
		r0 = rf(ctx, accountName, permissions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*interfaces.UserAccountAssociation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = rf(ctx, accountName, permissions)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChildAccounts provides a mock function with given fields: ctx, accountName, depth
func (_m *MockAccountManager) GetChildAccounts(ctx context.Context, accountName string, depth int) ([]*interfaces.Account, error) {
	ret := _m.Called(ctx, accountName, depth)

	if len(ret) == 0 {
		panic("no return value specified for GetChildAccounts")
	}

	var r0 []*interfaces.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int) ([]*interfaces.Account, error)); ok {
		return rf(ctx, accountName, depth)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int) []*interfaces.Account); ok {
		r0 = rf(ctx, accountName, depth)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*interfaces.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = rf(ctx, accountName, depth)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFairShareHierarchy provides a mock function with given fields: ctx, rootAccount
func (_m *MockAccountManager) GetFairShareHierarchy(ctx context.Context, rootAccount string) (*interfaces.FairShareHierarchy, error) {
	ret := _m.Called(ctx, rootAccount)

	if len(ret) == 0 {
		panic("no return value specified for GetFairShareHierarchy")
	}

	var r0 *interfaces.FairShareHierarchy
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*interfaces.FairShareHierarchy, error)); ok {
		return rf(ctx, rootAccount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *interfaces.FairShareHierarchy); ok {
		r0 = rf(ctx, rootAccount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.FairShareHierarchy)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, rootAccount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetParentAccounts provides a mock function with given fields: ctx, accountName
func (_m *MockAccountManager) GetParentAccounts(ctx context.Context, accountName string) ([]*interfaces.Account, error) {
	ret := _m.Called(ctx, accountName)

	if len(ret) == 0 {
		panic("no return value specified for GetParentAccounts")
	}

	var r0 []*interfaces.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*interfaces.Account, error)); ok {
		return rf(ctx, accountName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*interfaces.Account); ok {
		r0 = rf(ctx, accountName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*interfaces.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, accountName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields: ctx, opts
func (_m *MockAccountManager) List(ctx context.Context, opts *interfaces.ListAccountsOptions) (*interfaces.AccountList, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *interfaces.AccountList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *interfaces.ListAccountsOptions) (*interfaces.AccountList, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *interfaces.ListAccountsOptions) *interfaces.AccountList); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.AccountList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *interfaces.ListAccountsOptions) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: ctx, accountName, update
func (_m *MockAccountManager) Update(ctx context.Context, accountName string, update *interfaces.AccountUpdate) error {
	ret := _m.Called(ctx, accountName, update)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *interfaces.AccountUpdate) error); ok {
		r0 = rf(ctx, accountName, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidateUserAccess provides a mock function with given fields: ctx, userName, accountName
func (_m *MockAccountManager) ValidateUserAccess(ctx context.Context, userName string, accountName string) (*interfaces.UserAccessValidation, error) {
	ret := _m.Called(ctx, userName, accountName)

	if len(ret) == 0 {
		panic("no return value specified for ValidateUserAccess")
	}

	var r0 *interfaces.UserAccessValidation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*interfaces.UserAccessValidation, error)); ok {
		return rf(ctx, userName, accountName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *interfaces.UserAccessValidation); ok {
		r0 = rf(ctx, userName, accountName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.UserAccessValidation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, userName, accountName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewMockAccountManager creates a new instance of MockAccountManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccountManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccountManager {
	mock := &MockAccountManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
