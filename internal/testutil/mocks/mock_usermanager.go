// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	interfaces "github.com/jontk/slurm-client/interfaces"
	mock "github.com/stretchr/testify/mock"
)

// MockUserManager is an autogenerated mock type for the UserManager type
type MockUserManager struct {
	mock.Mock
}

// CalculateJobPriority provides a mock function with given fields: ctx, userName, jobSubmission
func (_m *MockUserManager) CalculateJobPriority(ctx context.Context, userName string, jobSubmission *interfaces.JobSubmission) (*interfaces.JobPriorityInfo, error) {
	ret := _m.Called(ctx, userName, jobSubmission)

	if len(ret) == 0 {
		panic("no return value specified for CalculateJobPriority")
	}

	var r0 *interfaces.JobPriorityInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *interfaces.JobSubmission) (*interfaces.JobPriorityInfo, error)); ok {
		return rf(ctx, userName, jobSubmission)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *interfaces.JobSubmission) *interfaces.JobPriorityInfo); ok {
		r0 = rf(ctx, userName, jobSubmission)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.JobPriorityInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *interfaces.JobSubmission) error); ok {
		r1 = rf(ctx, userName, jobSubmission)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Create provides a mock function with given fields: ctx, user
func (_m *MockUserManager) Create(ctx context.Context, user *interfaces.UserCreate) (*interfaces.UserCreateResponse, error) {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *interfaces.UserCreateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *interfaces.UserCreate) (*interfaces.UserCreateResponse, error)); ok {
		return rf(ctx, user)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *interfaces.UserCreate) *interfaces.UserCreateResponse); ok {
		r0 = rf(ctx, user)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.UserCreateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *interfaces.UserCreate) error); ok {
		r1 = rf(ctx, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAssociation provides a mock function with given fields: ctx, accountName, opts
func (_m *MockUserManager) CreateAssociation(ctx context.Context, accountName string, opts *interfaces.AssociationOptions) (*interfaces.AssociationCreateResponse, error) {
	ret := _m.Called(ctx, accountName, opts)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssociation")
	}

	var r0 *interfaces.AssociationCreateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *interfaces.AssociationOptions) (*interfaces.AssociationCreateResponse, error)); ok {
		return rf(ctx, accountName, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *interfaces.AssociationOptions) *interfaces.AssociationCreateResponse); ok {
		r0 = rf(ctx, accountName, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.AssociationCreateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *interfaces.AssociationOptions) error); ok {
		r1 = rf(ctx, accountName, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: ctx, userName
func (_m *MockUserManager) Delete(ctx context.Context, userName string) error {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, userName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: ctx, userName
func (_m *MockUserManager) Get(ctx context.Context, userName string) (*interfaces.User, error) {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *interfaces.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*interfaces.User, error)); ok {
		return rf(ctx, userName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *interfaces.User); ok {
		r0 = rf(ctx, userName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBulkAccountUsers provides a mock function with given fields: ctx, accountNames
func (_m *MockUserManager) GetBulkAccountUsers(ctx context.Context, accountNames []string) (map[string][]*interfaces.UserAccountAssociation, error) {
	ret := _m.Called(ctx, accountNames)

	if len(ret) == 0 {
		panic("no return value specified for GetBulkAccountUsers")
	}

	var r0 map[string][]*interfaces.UserAccountAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) (map[string][]*interfaces.UserAccountAssociation, error)); ok {
		return rf(ctx, accountNames)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) map[string][]*interfaces.UserAccountAssociation); ok {
		r0 = rf(ctx, accountNames)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]*interfaces.UserAccountAssociation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, accountNames)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBulkUserAccounts provides a mock function with given fields: ctx, userNames
func (_m *MockUserManager) GetBulkUserAccounts(ctx context.Context, userNames []string) (map[string][]*interfaces.UserAccount, error) {
	ret := _m.Called(ctx, userNames)

	if len(ret) == 0 {
		panic("no return value specified for GetBulkUserAccounts")
	}

	var r0 map[string][]*interfaces.UserAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) (map[string][]*interfaces.UserAccount, error)); ok {
		return rf(ctx, userNames)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) map[string][]*interfaces.UserAccount); ok {
		r0 = rf(ctx, userNames)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]*interfaces.UserAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, userNames)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserAccountAssociations provides a mock function with given fields: ctx, userName, opts
func (_m *MockUserManager) GetUserAccountAssociations(ctx context.Context, userName string, opts *interfaces.ListUserAccountAssociationsOptions) ([]*interfaces.UserAccountAssociation, error) {
	ret := _m.Called(ctx, userName, opts)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAccountAssociations")
	}

	var r0 []*interfaces.UserAccountAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *interfaces.ListUserAccountAssociationsOptions) ([]*interfaces.UserAccountAssociation, error)); ok {
		return rf(ctx, userName, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *interfaces.ListUserAccountAssociationsOptions) []*interfaces.UserAccountAssociation); ok {
		r0 = rf(ctx, userName, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*interfaces.UserAccountAssociation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *interfaces.ListUserAccountAssociationsOptions) error); ok {
		r1 = rf(ctx, userName, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserAccounts provides a mock function with given fields: ctx, userName
func (_m *MockUserManager) GetUserAccounts(ctx context.Context, userName string) ([]*interfaces.UserAccount, error) {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAccounts")
	}

	var r0 []*interfaces.UserAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*interfaces.UserAccount, error)); ok {
		return rf(ctx, userName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*interfaces.UserAccount); ok {
		r0 = rf(ctx, userName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*interfaces.UserAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserDefaultAccount provides a mock function with given fields: ctx, userName
func (_m *MockUserManager) GetUserDefaultAccount(ctx context.Context, userName string) (*interfaces.Account, error) {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for GetUserDefaultAccount")
	}

	var r0 *interfaces.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*interfaces.Account, error)); ok {
		return rf(ctx, userName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *interfaces.Account); ok {
		r0 = rf(ctx, userName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserFairShare provides a mock function with given fields: ctx, userName
func (_m *MockUserManager) GetUserFairShare(ctx context.Context, userName string) (*interfaces.UserFairShare, error) {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for GetUserFairShare")
	}

	var r0 *interfaces.UserFairShare
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*interfaces.UserFairShare, error)); ok {
		return rf(ctx, userName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *interfaces.UserFairShare); ok {
		r0 = rf(ctx, userName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.UserFairShare)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserQuotas provides a mock function with given fields: ctx, userName
func (_m *MockUserManager) GetUserQuotas(ctx context.Context, userName string) (*interfaces.UserQuota, error) {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for GetUserQuotas")
	}

	var r0 *interfaces.UserQuota
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*interfaces.UserQuota, error)); ok {
		return rf(ctx, userName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *interfaces.UserQuota); ok {
		r0 = rf(ctx, userName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.UserQuota)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields: ctx, opts
func (_m *MockUserManager) List(ctx context.Context, opts *interfaces.ListUsersOptions) (*interfaces.UserList, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *interfaces.UserList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *interfaces.ListUsersOptions) (*interfaces.UserList, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *interfaces.ListUsersOptions) *interfaces.UserList); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.UserList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *interfaces.ListUsersOptions) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: ctx, userName, update
func (_m *MockUserManager) Update(ctx context.Context, userName string, update *interfaces.UserUpdate) error {
	ret := _m.Called(ctx, userName, update)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *interfaces.UserUpdate) error); ok {
		r0 = rf(ctx, userName, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidateUserAccountAccess provides a mock function with given fields: ctx, userName, accountName
func (_m *MockUserManager) ValidateUserAccountAccess(ctx context.Context, userName string, accountName string) (*interfaces.UserAccessValidation, error) {
	ret := _m.Called(ctx, userName, accountName)

	if len(ret) == 0 {
		panic("no return value specified for ValidateUserAccountAccess")
	}

	var r0 *interfaces.UserAccessValidation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*interfaces.UserAccessValidation, error)); ok {
		return rf(ctx, userName, accountName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *interfaces.UserAccessValidation); ok {
		r0 = rf(ctx, userName, accountName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interfaces.UserAccessValidation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, userName, accountName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewMockUserManager creates a new instance of MockUserManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserManager {
	mock := &MockUserManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
